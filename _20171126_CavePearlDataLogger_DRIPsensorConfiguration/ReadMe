Readme file for 20171126_CavePearlDataLogger_DRIPsensorConfiguration:

This uses the Cave Pearl data logger as an event counter with an ISR responding to hardware interrrupts on line D3 of a pro-mini style 
Arduino, which counts the number of alarm interrupts generated by an accelerometer in tap sensing mode. We use these for drip counting
for cave research:
https://edwardmallon.wordpress.com/category/developing-a-drip-%E2%9A%B6-sensor/

but we also use exactly the same code to record switch closures on traditional tipping bucket Rain gauges:
https://edwardmallon.wordpress.com/2015/06/15/developing-an-arduino-based-weather-station/ 

The key insight into the operation of this code is that there is a while-loop a the very end of the main loop 
which "traps" the processor in the event counting routine until the RTC alarm fires:

void loop ()
{
//...read rtc, make timestamp...
//...sensor readings....
//...data buffering....
//...if eeprom full - flush data to the SD card...
//...set next alarm time...

#if defined(AdxlDripSensor) || defined(TipBucket_RainGauge)       //this is the "sub-loop" that acts as an event counter
while (rtc_INT0_Flag == false) { 
//...stuff in here for handling the D3 alarms: debouncing delays, etc....
sleepNwait4D3Interrupt();    // the ISRs that wake from this sleep function set either INT1_Flag = true;  OR  rtc_INT0_Flag = true;
}                               // end of while (rtc_INT0_Flag == false)
#endif

// you only break out of the while-loop when rtc_INT0_Flag = true - so the RTC, rather than the acceleometer fired the alarm
// proceed back to start of main loop and read all sensors

}  //end of void loop ()


