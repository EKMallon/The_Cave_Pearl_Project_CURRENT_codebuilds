<img src="https://github.com/EKMallon/The_Cave_Pearl_Project_CURRENT_codebuilds/blob/master/images/CavePearlProjectBanner_130x850px.jpg">

# 20171126_CavePearlDataLogger_DRIPsensorConfiguration:

This uses the Cave Pearl data logger as an event counter with an ISR responding to hardware interrrupts
on line D3 of a pro-mini style Arduino, which counts the number of alarm interrupts generated by 
an accelerometer in tap sensing mode. We use these as drip counters to study vadose zone hydrology 
in Karst cave systems:
https://edwardmallon.wordpress.com/category/developing-a-drip-%E2%9A%B6-sensor/

but since interrupt event counting is a fairly generic application, we also use the same code to 
record reed switch closures on traditional tipping bucket Rain gauges:
https://edwardmallon.wordpress.com/2015/06/15/developing-an-arduino-based-weather-station/ 

This self-documenting code is extensively commented with verbose variable names to describe functions.

The key insight into the operation of this Event-counting variant is that there is a while-loop 
at the very end of the main loop which **"traps" the processor** until the RTC alarm fires:

```
void loop ()
{

// the main loop proceeds through a set of standard sample-interval events  (common to ALL code variants)
1) read rtc, make current timestamp
2) check if new log file needs to be generated
3) capture new sensor readings
4a) concatenate sensor data to EEPROMBuffer char array with Pstring
4b) buffer that array to eeprom (step 4 repeats 2x)
5) if eeprom memory is full - flush eeprom data to the SD card
6) if midnight rollover occurs, trigger oncePerDayEvents() to save daily totals to StatusLog.csv 
7) set next alarm time based on SampleIntervalMinutes variable

//After running through those standard tasks, EVENT counters are captured by this #if defined statement:
#if defined(AdxlDripSensor) || defined(TipBucket_RainGauge)  //the EVENT counter "sub-loop"

while (rtc_INT0_Flag == false) { 

//...stuff in here for handling the D3 alarms with debouncing delays, register resets, etc....

sleepNwait4D3Interrupt();    // ISRs from this function set EITHER INT1_Flag = true;  OR  rtc_INT0_Flag = true;
} 
// you only break out of this while-loop when rtc_INT0_Flag = true 
// so the RTC alarm has fired on D2, rather than the D3 based interrupt. 

#else

sleepNwait4RTC();      //this is the standard RTC-ALARM-ONLY processor sleeping routine
// used when no other interrupt generating device (Adxl345/TipBucket/etc) is connected to D3

#endif  // for #if defined(AdxlDripSensor) || defined(TipBucket_RainGauge)

}  //end of void loop ()  //from here the code proceeds back to start of main loop
```

